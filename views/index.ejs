<!DOCTYPE html>
<html>
    <head>
        <link href="/css/index.css" rel="stylesheet">
        <script src="/socket.io/socket.io.js"></script>
        <title>Virtual Machine Controll Panel</title>
    </head>
    <body>
        <div class="my-contextmenu" id="router-contextmenu">
            <ul>
                <li><a href="">add port</a></li>
            </ul>
        </div>

        <div id="topmenu">
            <div id="title">
                <img src="/image/icon.png" height="50">
                Virtual Machine Controll Panel
            </div>
            <ul>
                <li><a href="#">Reset</a></li>
                <li><a href="#">Logout</a></li>
            </ul>
        </div>
        <div class="container">
            <div id="sidemenu" onContextmenu="return false;">
                <ul>
                    <li draggable="true" id="router">
                        <img src="/image/router.png">
                    </li>
                    <li draggable="true" id="switch">
                        <img src="/image/switch.png">
                    </li>
                    <li draggable="true" id="vps">
                        <img src="/image/vps.png">
                    </li>
                </ul>
            </div>
            <div id="uipanel" onContextmenu="return false;">
                <canvas id="canvasui" width="1000" height="550">

                </canvas>
            </div>
        </div>
        <div id="controlpanel">
            <div id="tabmenu">
            </div>
            <div id="log">

            </div>
        </div>
        <script>
            let socket = io();

            /**
             * サイドメニューの機器アイコンをドラッグしたとき発火
             * 機器の種類を控えて, canvas上を若干透過する
             */
            function handleDragStart(e){
                e.dataTransfer.setData('machin', this.id); //idで機器の種類が取れる
                dropArea.style.opacity = 0.3;
            }

            /**
             * ドラッグが終了したときに発火
             * 透過されたcanvasを元に戻す
             */
            function handleDragEnd(e){
                dropArea.style.opacity = 1;
            }

            /**
             * canvas上に機器がドラッグされたときに発火
             * 機器に対応したurlにajax通信でPOSTしcanvas上に描画をする
             * 同時にinUseMachinリストに機器のオブジェクトを格納する
             */
            function handleDrop(e){
                let img = new Image();
                let machine = e.dataTransfer.getData('machin');
                if (machine == "router"){
                    img.src = ROUTER_SRC;
                    let prm = new URLSearchParams();
                    prm.append("x", 30);
                    prm.append("y", 30);
                    PostRequest("/machine/router/add", prm);
                }
                else if (machine == "switch"){
                    img.src = SWITCH_SRC;
                    let prm = new URLSearchParams();
                    prm.append("x", 30);
                    prm.append("y", 30);
                    PostRequest("/machine/switch/add", prm);
                }
                else if (machine == "vps"){
                    img.src = VM_SRC;
                    let prm = new URLSearchParams();
                    prm.append("x", 30);
                    prm.append("y", 30);
                    PostRequest("/machine/vm/add", prm);
                }
                let x = e.clientX - canvas.getBoundingClientRect().left;
                let y = e.clientY - canvas.getBoundingClientRect().top;
                context.drawImage(img, x, y);
                inUseMachines.push(new Machin(img, 1, x, y));
                socket.emit('addmachine', machine);
            }
            
            //機器の画像パスの定数
            const ROUTER_SRC = "/image/router.png";
            const SWITCH_SRC = "/image/switch.png";
            const VM_SRC = "/image/vps.png";

            //ここからDnDのイベント登録
            var cols = document.querySelectorAll('#sidemenu ul li');
            [].forEach.call(cols, function(col) {
                col.addEventListener('dragstart', handleDragStart, false);
                col.addEventListener('dragend', handleDragEnd, false);
            });
            var dropArea = document.getElementById("uipanel");
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
            }, false);
            dropArea.addEventListener('drop', handleDrop, false);
            //DnDのイベント登録ここまで

            /**
             * canvas上でクリックされたら発火
             * クリックされた座標に機器があれば移動変数moveMachineにぶち込む
             */
            function handleCanvasOnDown(e){
                let offsetX = canvas.getBoundingClientRect().left;
                let offsetY = canvas.getBoundingClientRect().top;
                let x = e.clientX - offsetX;
                let y = e.clientY - offsetY;
                inUseMachines.forEach(function(machin){
                    if (checkLoacationOverMachin(machin, x, y)){
                        canvasDragging = true; //trueの間だけ動かせる
                        relX = machin.x - x;
                        relY = machin.y -y;
                        moveMachin = machin; //ここにぶちこんだやつが動く
                    }
                });

            }

            /**
             * canvas上でマウスカーソルが動いたら発火する
             * canvasDraggingをつかってドラックでmoveMachinの機器を動かせる
             */
            function handleCanvasOnMove(e){
                if (canvasDragging){
                    let offsetX = canvas.getBoundingClientRect().left;
                    let offsetY = canvas.getBoundingClientRect().top;
                    let x = e.clientX - offsetX;
                    let y = e.clientY - offsetY;
                    moveMachin.x = x + relX;
                    moveMachin.y = y + relY;
                    canvasReDraw();
                }
            }

            /**
             * canvas上でクリックをやめたら発火
             * canvasDraggingをfalseにし動けなくする
             */
            function handleCanvasOnUp(e){
                canvasDragging = false;
            }

            function handleCanvasDoubleClick(e){
                console.log('double click');
            }

            /**
             * 現在の座標が機器の上か確認
             * @param {machine} machine 検証する機器オブジェクト
             * @param {number} x x座標
             * @param {number} y y座標
             */
            function checkLoacationOverMachin(machine, x, y){
                if (machine.x < x && (machine.img.naturalWidth + machine.x) > x && machine.y < y && (machine.img.naturalHeight + machine.y) > y)
                    return true;
                else
                return false;
            }

            /**
             * canvasを再描画する
             */
            function canvasReDraw(){
                context.clearRect(0, 0, canvas.width, canvas.height);
                inUseMachines.forEach(function(machin){
                    context.drawImage(machin.img, machin.x, machin.y);
                });
            }

            //ここからcanvas上のイベント登録
            const canvas = document.getElementById("canvasui");
            let context = canvas.getContext('2d');
            canvas.addEventListener('mousedown', handleCanvasOnDown, false);
            canvas.addEventListener('mousemove', handleCanvasOnMove, false);
            canvas.addEventListener('mouseup', handleCanvasOnUp, false);
            canvas.addEventListener('dblclick', handleCanvasDoubleClick, false);
            let canvasDragging = false;
            let inUseMachines = []
            let cables = []
            let relX, relY;
            let moveMachin;
            //canvas上のイベント登録ここまで

            /**
             * 機器上で右クリックしたときに独自のコンテキストメニューを出す処理
             */
            let routerContextMenu = document.getElementById('router-contextmenu');
            canvas.addEventListener('contextmenu', function(e){
                let offsetX = canvas.getBoundingClientRect().left;
                let offsetY = canvas.getBoundingClientRect().top;
                let x = e.clientX - offsetX;
                let y = e.clientY - offsetY;
                inUseMachines.forEach(function(machin){
                    if (checkLoacationOverMachin(machin, x, y)){
                        routerContextMenu.style.left = (x + offsetX)+'px';
                        routerContextMenu.style.top = (y + offsetY)+'px';
                        routerContextMenu.classList.add('show');
                        canvasDragging = false;
                        return;
                    }
                });
            }, false);
            document.body.addEventListener('click',function(){
                if(routerContextMenu.classList.contains('show')) {
                routerContextMenu.classList.remove('show');
                }
            });
            //コンテキストメニューここまで
            

            function Machin(img, id, x, y){
                this.img = img;
                this.id = id;
                this.x = x;
                this.y = y;
            }


            /**
             * 指定されたurlにPOSTする
             * POST後ログエリアに結果を表示
             * @param {string} url url
             * @param {URLSearchParams} 送信データ
             */
            function PostRequest(url, params){
                let req = new Request(url, {
                    method: "post",
                    body: params
                });
                fetch(req)
                .then(response =>{
                    return response.text();
                }).then(text => {
                    Stdout(text);
                });
            }
            
            const log = document.getElementById("log");
            /**
             * ログエリアにログを追記する
             * @param {string} str 追記する出力文字
             */
            function Stdout(str){
                log.insertAdjacentHTML('beforeend', '<p>' + str + '</p>');
            }

            /**
             * ログエリアにエラーログを追記する
             * @param {string} str 追記する出力文字
             */
            function Stderr(str){

            }
        </script>
    </body>
</html>