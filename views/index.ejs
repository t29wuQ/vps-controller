<!DOCTYPE html>
<html>
    <head>
        <link href="/css/index.css" rel="stylesheet">
        <script src="/socket.io/socket.io.js"></script>
        <title>Virtual Machine Controll Panel</title>
    </head>
    <body>
        <div class="my-contextmenu" id="contextmenu">
            <ul>
                <li><a href="javascript:void(0);" onclick="AddPort();">add port</a></li>
            </ul>
        </div>

        <div id="topmenu">
            <div id="title">
                <img src="/image/icon.png" height="50">
                Virtual Machine Controll Panel
            </div>
            <ul>
                <li><a href="#">Reset</a></li>
                <li><a href="#">Logout</a></li>
            </ul>
        </div>
        <div class="container">
            <div id="sidemenu" onContextmenu="return false;">
                <ul>
                    <li draggable="true" id="router">
                        <img src="/image/router.png">
                    </li>
                    <li draggable="true" id="switch">
                        <img src="/image/switch.png">
                    </li>
                    <li draggable="true" id="vps">
                        <img src="/image/vps.png">
                    </li>
                </ul>
            </div>
            <div id="uipanel" onContextmenu="return false;">
                <canvas id="canvasui" width="1000" height="550">

                </canvas>
            </div>
        </div>
        <div id="controlpanel">
            <div id="tabmenu">
            </div>
            <div id="log">

            </div>
        </div>
        <script>
            //let socket = io();

            /**
             * サイドメニューの機器アイコンをドラッグしたとき発火
             * 機器の種類を控えて, canvas上を若干透過する
             */
            function handleDragStart(e){
                e.dataTransfer.setData('machin', this.id); //idで機器の種類が取れる
                dropArea.style.opacity = 0.3;
            }

            /**
             * ドラッグが終了したときに発火
             * 透過されたcanvasを元に戻す
             */
            function handleDragEnd(e){
                dropArea.style.opacity = 1;
            }

            /**
             * canvas上に機器がドラッグされたときに発火
             * 機器に対応したurlにajax通信でPOSTしcanvas上に描画をする
             * 同時にinUseMachinリストに機器のオブジェクトを格納する
             */
            function handleDrop(e){
                let img = new Image();
                let type = e.dataTransfer.getData('machin');
                let x = e.clientX - canvas.getBoundingClientRect().left;
                let y = e.clientY - canvas.getBoundingClientRect().top;
                let params = new URLSearchParams();
                params.append("x", x);
                params.append("y", y);
                let url = ""
                if (type== "router"){
                    img.src = ROUTER_SRC;
                    url = "/machine/router/add";
                }
                else if (type == "switch"){
                    img.src = SWITCH_SRC;
                    url = "/machine/switch/add";
                }
                else if (type == "vps"){
                    img.src = VM_SRC;
                    url = "/machine/vm/add";
                }
                let req = new Request(url, {
                    method: "post",
                    body: params
                });
                fetch(req)
                .then(response =>{
                    return response.json();
                }).then(json => {
                    if (json.status == 0){
                        inUseMachines.push(new Machine(img, json.id, json.name, "", type, x, y));
                        canvasReDraw();
                    }
                    Stdout(json.log);
                });
                //socket.emit('addmachine', machine);
            }
            
            //機器の画像パスの定数
            const ROUTER_SRC = "/image/router.png";
            const SWITCH_SRC = "/image/switch.png";
            const VM_SRC = "/image/vps.png";

            //ここからDnDのイベント登録
            var cols = document.querySelectorAll('#sidemenu ul li');
            [].forEach.call(cols, function(col) {
                col.addEventListener('dragstart', handleDragStart, false);
                col.addEventListener('dragend', handleDragEnd, false);
            });
            var dropArea = document.getElementById("uipanel");
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
            }, false);
            dropArea.addEventListener('drop', handleDrop, false);
            //DnDのイベント登録ここまで

            /**
             * canvas上でクリックされたら発火
             * クリックされた座標に機器があれば移動変数moveMachineにぶち込む
             */
            function handleCanvasOnDown(e){
                let offsetX = canvas.getBoundingClientRect().left;
                let offsetY = canvas.getBoundingClientRect().top;
                let x = e.clientX - offsetX;
                let y = e.clientY - offsetY;
                if (vethDrawing){
                    inUseMachines.forEach(function(machine){
                        if (checkLoacationOverMachin(machine, x, y)){
                            console.log("veth connect");
                            vethDrawing = false;
                            end_x = machine.x + machine.img.naturalWidth / 2;
                            end_y = machine.y + machine.img.naturalHeight / 2;
                            let params = new URLSearchParams();
                            params.append("attach_machine_port1", now_context.name);
                            params.append("attach_machine_port2", machine.name);
                            params.append("port1_number", 1);
                            params.append("port2_number", 1);
                            params.append("begin_x", begin_x);
                            params.append("begin_y", begin_y);
                            params.append("end_x", end_x);
                            params.append("end_y", end_y);
                            let req = new Request("/machine/veth/add", {
                                method: "post",
                                body: params
                            });
                            fetch(req)
                            .then(response =>{
                                return response.json();
                            }).then(json => {
                                console.log(json.log);
                                canvasReDraw();
                                context.beginPath();
                                context.moveTo(begin_x, begin_y);
                                context.lineTo(end_x, end_y);
                                context.stroke();
                            });
                        }
                    });
                    //canvasReDraw();
                    return;
                }
                inUseMachines.forEach(function(machine){
                    if (checkLoacationOverMachin(machine, x, y)){
                        canvasDragging = true; //trueの間だけ動かせる
                        relX = machine.x - x;
                        relY = machine.y -y;
                        moveMachine = machine; //ここにぶちこんだやつが動く
                    }
                });
            }

            /**
             * canvas上でマウスカーソルが動いたら発火する
             * canvasDraggingをつかってドラックでmoveMachinの機器を動かせる
             * vethDrawingがtrueのときport追加モード
             */
            function handleCanvasOnMove(e){
                let offsetX = canvas.getBoundingClientRect().left;
                let offsetY = canvas.getBoundingClientRect().top;
                let x = e.clientX - offsetX;
                let y = e.clientY - offsetY;
                if (canvasDragging){
                    moveMachine.x = x + relX;
                    moveMachine.y = y + relY;
                    canvasReDraw();
                }
                if (vethDrawing){
                    canvasReDraw();
                    begin_x = now_context.x + now_context.img.naturalWidth / 2;
                    begin_y = now_context.y + now_context.img.naturalHeight / 2;
                    context.beginPath();
                    context.moveTo(begin_x, begin_y);
                    context.lineTo(x, y);
                    context.stroke();
                }
            }

            /**
             * canvas上でクリックをやめたら発火
             * canvasDraggingをfalseにし動けなくする
             */
            function handleCanvasOnUp(e){
                canvasDragging = false;
            }

            function handleCanvasDoubleClick(e){
                console.log('double click');
            }

            /**
             * 現在の座標が機器の上か確認
             * @param {machine} machine 検証する機器オブジェクト
             * @param {number} x x座標
             * @param {number} y y座標
             */
            function checkLoacationOverMachin(machine, x, y){
                if (machine.x < x && (machine.img.naturalWidth + machine.x) > x && machine.y < y && (machine.img.naturalHeight + machine.y) > y)
                    return true;
                else
                return false;
            }

            /**
             * canvasを再描画する
             */
            function canvasReDraw(){
                context.clearRect(0, 0, canvas.width, canvas.height);
                inUseMachines.forEach(function(machine){
                    context.drawImage(machine.img, machine.x, machine.y);
                });
            }

            //ここからcanvas上のイベント登録
            const canvas = document.getElementById("canvasui");
            let context = canvas.getContext('2d');
            canvas.addEventListener('mousedown', handleCanvasOnDown, false);
            canvas.addEventListener('mousemove', handleCanvasOnMove, false);
            canvas.addEventListener('mouseup', handleCanvasOnUp, false);
            canvas.addEventListener('dblclick', handleCanvasDoubleClick, false);
            let canvasDragging = false;
            let inUseMachines = []
            let cables = []
            let relX, relY;
            let moveMachine;
            //canvas上のイベント登録ここまで

            /**
             * 機器上で右クリックしたときに独自のコンテキストメニューを出す処理
             */
            let contextMenu = document.getElementById('contextmenu');
            let now_context = "";
            let begin_x = 0;
            let begin_y = 0;
            let end_x = 0;
            let end_y = 0;
            let vethDrawing = false;
            canvas.addEventListener('contextmenu', function(e){
                if (vethDrawing){
                    vethDrawing = false;
                    canvasReDraw();
                }
                let offsetX = canvas.getBoundingClientRect().left;
                let offsetY = canvas.getBoundingClientRect().top;
                let x = e.clientX - offsetX;
                let y = e.clientY - offsetY;
                inUseMachines.forEach(function(machine){
                    if (checkLoacationOverMachin(machine, x, y)){
                        contextMenu.style.left = (x + offsetX)+'px';
                        contextMenu.style.top = (y + offsetY)+'px';
                        contextMenu.classList.add('show');
                        let html = "<ul>";
                        console.log(machine.port);
                        for (i = 0;i < machine.port.length;i++){
                            if (machine.port.status == 2)
                                html += '<li color="green">Ethernet' + i + ' 接続中</li>';
                            else
                                html += '<li><a href="javascript:void(0);" onclick="AddPort(' + i + ');">Ethernet' + i + '</a></li>';
                        }
                        html += "</ul>"
                        contextMenu.innerHTML = html;
                        canvasDragging = false;
                        now_context = machine;
                        return;
                    }
                });
            }, false);
            document.body.addEventListener('click',function(){
                if(contextMenu.classList.contains('show')) {
                contextMenu.classList.remove('show');
                }
            });
            //コンテキストメニューここまで

            function AddPort(port_number){
                vethDrawing = true;
            }



            function Machine(img, id, name, description, type, x, y){
                this.img = img;
                this.id = id
                this.name = name;
                this.description = description;
                this.type = type;
                this.x = x;
                this.y = y;
                this.port = [];
            }

            function Port(id ,name, access_point, port_number, x, y, ip_address, mac_address){
                this.id = id;
                thiss.name = name;
                this.access_point = access_point;
                this.port_number = port_number
                this.x = x;
                this.y = y;
                this.ip_address = ip_address;
                this.mac_address = mac_address;
            }


            /**
             * 指定されたurlにPOSTする
             * POST後ログエリアに結果を表示
             * @param {string} url url
             * @param {URLSearchParams} 送信データ
             */
            function PostRequest(url, params){
                let req = new Request(url, {
                    method: "post",
                    body: params
                });
                fetch(req)
                .then(response =>{
                    return response.json();
                }).then(json => {
                    new Machine
                    Stdout(json.log);
                });
            }
            
            const log = document.getElementById("log");
            /**
             * ログエリアにログを追記する
             * @param {string} str 追記する出力文字
             */
            function Stdout(str){
                log.insertAdjacentHTML('beforeend', '<p>' + str + '</p>');
            }

            /**
             * ログエリアにエラーログを追記する
             * @param {string} str 追記する出力文字
             */
            function Stderr(str){

            }
        </script>
    </body>
</html>